import numpy as np
from qutip import tensor, basis, sigmax, sigmay, sigmaz, qeye, rx, ry, rz, snot, cnot, ket2dm, tracedist
from copy import deepcopy

### QuantumCircuitEnv environment

class QuantumCircuitEnv2Qubits:

    def __init__(self, max_circuit_depth, goal_state, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = ['X0', 'Y0', 'Z0', 'H0',
                             'X1', 'Y1', 'Z1', 'H1',
                             'CNOT10']
        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = 2                        # Number of qubits in circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action):
        # Matrices representation of the possible gates
        if   action == 'X0': return (tensor(sigmax(), qeye(2)), 1.54)
        elif action == 'Y0': return (tensor(sigmay(), qeye(2)), 1.54)
        elif action == 'Z0': return (tensor(sigmaz(), qeye(2)), 1.54)
        elif action == 'H0': return (tensor(snot(N=1), qeye(2))  , 1.5)
        elif action == 'X1': return (tensor(qeye(2), sigmax()), 5.15)
        elif action == 'Y1': return (tensor(qeye(2), sigmay()), 5.15)
        elif action == 'Z1': return (tensor(qeye(2), sigmaz()), 5.15)
        elif action == 'H1': return (tensor(qeye(2), snot(N=1)), 5.15)
        elif action == 'CNOT10': return (cnot(N=2, control=1, target=0), 23.8)

    # Update circuit depth
    def calculate_circuit_depth(self, a):
        if a == 'X0' or a == 'Y0' or a == 'Z0' or a == 'H0':
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)
        elif a == 'X1' or a == 'Y1' or a == 'Z1' or a == 'H1':
            self.circuit_depths[1] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[1].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT10':
            self.circuit_depths[1] = max(self.circuit_depths[0], self.circuit_depths[1])
            self.circuit_depths[0] = max(self.circuit_depths[0], self.circuit_depths[1])
            self.circuit_depths[1] += 1
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[1].append(a)
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return 100
        else:
            return 0

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self,action):
        s_prev = self.s
        a, e = self.action2matrix(action)
        self.sum_error += e
        self.s = a*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action)
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if max(self.circuit_depths) > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            output = open('output.out', 'a')
            print("Gates:", file = output)
            print("qubit 0: ", self.circuit_gates[0], file = output)
            print("qubit 1: ", self.circuit_gates[1], file = output)
            print("min circuit depth: ", self.min_circuit_depth, file = output)
            print("Reward", reward, file = output)
            print("\n", file = output)
            output.close()
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |00>
    def init_comp_basis(self):
        comp_basis = tensor(basis(2,0), basis(2,0))
        return comp_basis

class QuantumCircuitEnv3Qubits:

    def __init__(self, max_circuit_depth, goal_state, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = ['X0', 'Y0', 'Z0', 'H0',
                             'X1', 'Y1', 'Z1', 'H1',
                             'X2', 'Y2', 'Z2', 'H2',
                             'CNOT10', 'CNOT20', 'CNOT21']
        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = 3                        # Number of qubits in circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action):
        # Matrices representation of the possible gates
        if   action == 'X0': return (tensor(sigmax(), qeye(2), qeye(2)), 1.54)
        elif action == 'Y0': return (tensor(sigmay(), qeye(2), qeye(2)), 1.54)
        elif action == 'Z0': return (tensor(sigmaz(), qeye(2), qeye(2)), 1.54)
        elif action == 'H0': return (tensor(snot(N=1), qeye(2), qeye(2))  , 1.54)
        elif action == 'X1': return (tensor(qeye(2), sigmax(), qeye(2)), 5.15)
        elif action == 'Y1': return (tensor(qeye(2), sigmay(), qeye(2)), 5.15)
        elif action == 'Z1': return (tensor(qeye(2), sigmaz(), qeye(2)), 5.15)
        elif action == 'H1': return (tensor(qeye(2), snot(N=1), qeye(2))  , 5.15)
        elif action == 'X2': return (tensor(qeye(2), qeye(2), sigmax()), 2.4)
        elif action == 'Y2': return (tensor(qeye(2), qeye(2), sigmay()), 2.4)
        elif action == 'Z2': return (tensor(qeye(2), qeye(2), sigmaz()), 2.4)
        elif action == 'H2': return (tensor(qeye(2), qeye(2), snot(N=1))  , 2.4)
        elif action == 'CNOT10': return (cnot(N=3, control=1, target=0), 24.8)
        elif action == 'CNOT20': return (cnot(N=3, control=2, target=0), 23.8)
        elif action == 'CNOT21': return (cnot(N=3, control=2, target=1), 49.7)

    # Update circuit depth
    def calculate_circuit_depth(self, a):
        if a == 'X0' or a == 'Y0' or a == 'Z0' or a == 'H0':
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)
        elif a == 'X1' or a == 'Y1' or a == 'Z1' or a == 'H1':
            self.circuit_depths[1] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[1].append(a)
                return max(self.circuit_depths)
        elif a == 'X2' or a == 'Y2' or a == 'Z2' or a == 'H2':
            self.circuit_depths[2] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[2].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT10':
            self.circuit_depths[1] = max(self.circuit_depths[0], self.circuit_depths[1])
            self.circuit_depths[0] = max(self.circuit_depths[0], self.circuit_depths[1])
            self.circuit_depths[1] += 1
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[1].append(a)
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT20':
            self.circuit_depths[2] = max(self.circuit_depths[0], self.circuit_depths[2])
            self.circuit_depths[0] = max(self.circuit_depths[0], self.circuit_depths[2])
            self.circuit_depths[2] += 1
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[2].append(a)
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT21':
            self.circuit_depths[2] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[1] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[2] += 1
            self.circuit_depths[1] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[2].append(a)
                self.circuit_gates[1].append(a)
                return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return 150
        else:
            return 0

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self,action):
        s_prev = self.s
        a, e = self.action2matrix(action)
        self.sum_error += e
        self.s = a*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action)
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if max(self.circuit_depths) > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            output = open('output.out', 'a')
            print("Gates:", file = output)
            print("qubit 0: ", self.circuit_gates[0], file = output)
            print("qubit 1: ", self.circuit_gates[1], file = output)
            print("qubit 2: ", self.circuit_gates[2], file = output)
            print("min circuit depth: ", self.min_circuit_depth, file = output)
            print("Reward", reward, file = output)
            print("\n", file = output)
            output.close()
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |000>
    def init_comp_basis(self):
        comp_basis = tensor(basis(2,0), basis(2,0), basis(2,0))
        return comp_basis

class QuantumCircuitEnv4Qubits:

    def __init__(self, max_circuit_depth, goal_state, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = ['X0', 'Y0', 'Z0', 'H0',
                             'X1', 'Y1', 'Z1', 'H1',
                             'X2', 'Y2', 'Z2', 'H2',
                             'X3', 'Y3', 'Z3', 'H3',
                             'CNOT10', 'CNOT20', 'CNOT21', 'CNOT32']
        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = 4                        # Number of qubits in circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action):
        # Matrices representation of the possible gates
        if   action == 'X0': return (tensor(sigmax(), qeye(2), qeye(2), qeye(2)), 1.54)
        elif action == 'Y0': return (tensor(sigmay(), qeye(2), qeye(2), qeye(2)), 1.54)
        elif action == 'Z0': return (tensor(sigmaz(), qeye(2), qeye(2), qeye(2)), 1.54)
        elif action == 'H0': return (tensor(snot(N=1), qeye(2), qeye(2), qeye(2))  , 1.54)
        elif action == 'X1': return (tensor(qeye(2), sigmax(), qeye(2), qeye(2)), 5.15)
        elif action == 'Y1': return (tensor(qeye(2), sigmay(), qeye(2), qeye(2)), 5.15)
        elif action == 'Z1': return (tensor(qeye(2), sigmaz(), qeye(2), qeye(2)), 5.15)
        elif action == 'H1': return (tensor(qeye(2), snot(N=1), qeye(2), qeye(2))  , 5.15)
        elif action == 'X2': return (tensor(qeye(2), qeye(2), sigmax(), qeye(2)), 2.4)
        elif action == 'Y2': return (tensor(qeye(2), qeye(2), sigmay(), qeye(2)), 2.4)
        elif action == 'Z2': return (tensor(qeye(2), qeye(2), sigmaz(), qeye(2)), 2.4)
        elif action == 'H2': return (tensor(qeye(2), qeye(2), snot(N=1), qeye(2))  , 2.4)
        elif action == 'X3': return (tensor(qeye(2), qeye(2), qeye(2), sigmax()), 2.74)
        elif action == 'Y3': return (tensor(qeye(2), qeye(2), qeye(2), sigmay()), 2.74)
        elif action == 'Z3': return (tensor(qeye(2), qeye(2), qeye(2), sigmaz()), 2.74)
        elif action == 'H3': return (tensor(qeye(2), qeye(2), qeye(2), snot(N=1))  , 2.74)
        elif action == 'CNOT10': return (cnot(N=4, control=1, target=0), 24.8)
        elif action == 'CNOT20': return (cnot(N=4, control=2, target=0), 23.8)
        elif action == 'CNOT21': return (cnot(N=4, control=2, target=1), 49.7)
        elif action == 'CNOT32': return (cnot(N=4, control=3, target=2), 52.2)

    # Update circuit depth
    def calculate_circuit_depth(self, a):
        if a == 'X0' or a == 'Y0' or a == 'Z0' or a == 'H0':
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)
        elif a == 'X1' or a == 'Y1' or a == 'Z1' or a == 'H1':
            self.circuit_depths[1] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[1].append(a)
                return max(self.circuit_depths)
        elif a == 'X2' or a == 'Y2' or a == 'Z2' or a == 'H2':
            self.circuit_depths[2] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[2].append(a)
                return max(self.circuit_depths)
        elif a == 'X3' or a == 'Y3' or a == 'Z3' or a == 'H3':
            self.circuit_depths[3] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[3].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT10':
            self.circuit_depths[1] = max(self.circuit_depths[0], self.circuit_depths[1])
            self.circuit_depths[0] = max(self.circuit_depths[0], self.circuit_depths[1])
            self.circuit_depths[1] += 1
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[1].append(a)
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT20':
            self.circuit_depths[2] = max(self.circuit_depths[0], self.circuit_depths[2])
            self.circuit_depths[0] = max(self.circuit_depths[0], self.circuit_depths[2])
            self.circuit_depths[2] += 1
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[2].append(a)
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT21':
            self.circuit_depths[2] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[1] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[2] += 1
            self.circuit_depths[1] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[2].append(a)
                self.circuit_gates[1].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT32':
            self.circuit_depths[3] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[2] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[3] += 1
            self.circuit_depths[2] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[3].append(a)
                self.circuit_gates[2].append(a)
                return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return 200
        else:
            return 0

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self,action):
        s_prev = self.s
        a, e = self.action2matrix(action)
        self.sum_error += e
        self.s = a*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action)
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if max(self.circuit_depths) > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            output = open('output.out', 'a')
            print("Gates:\n", file = output)
            print("qubit 0: ", self.circuit_gates[0], file = output)
            print("qubit 1: ", self.circuit_gates[1], file = output)
            print("qubit 2: ", self.circuit_gates[2], file = output)
            print("qubit 3: ", self.circuit_gates[3], file = output)
            print("min circuit depth: ", self.min_circuit_depth, file = output)
            print("Right circuit", reward, file = output)
            print("\n", file = output)
            output.close()
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |0000>
    def init_comp_basis(self):
        comp_basis = tensor(basis(2,0), basis(2,0), basis(2,0), basis(2,0))
        return comp_basis

class QuantumCircuitEnv5Qubits:

    def __init__(self, max_circuit_depth, goal_state, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = ['X0', 'Y0', 'Z0', 'H0',
                             'X1', 'Y1', 'Z1', 'H1',
                             'X2', 'Y2', 'Z2', 'H2',
                             'X3', 'Y3', 'Z3', 'H3',
                             'X4', 'Y4', 'Z4', 'H4',
                             'CNOT10', 'CNOT20', 'CNOT21',
                             'CNOT32', 'CNOT34', 'CNOT42']
        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = 5                        # Number of qubits in circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action):
        # Matrices representation of the possible gates
        if   action == 'X0': return (tensor(sigmax(), qeye(2), qeye(2), qeye(2), qeye(2)), 1.54)
        elif action == 'Y0': return (tensor(sigmay(), qeye(2), qeye(2), qeye(2), qeye(2)), 1.54)
        elif action == 'Z0': return (tensor(sigmaz(), qeye(2), qeye(2), qeye(2), qeye(2)), 1.54)
        elif action == 'H0': return (tensor(snot(N=1), qeye(2), qeye(2), qeye(2), qeye(2))  , 1.54)
        elif action == 'X1': return (tensor(qeye(2), sigmax(), qeye(2), qeye(2), qeye(2)), 5.15)
        elif action == 'Y1': return (tensor(qeye(2), sigmay(), qeye(2), qeye(2), qeye(2)), 5.15)
        elif action == 'Z1': return (tensor(qeye(2), sigmaz(), qeye(2), qeye(2), qeye(2)), 5.15)
        elif action == 'H1': return (tensor(qeye(2), snot(N=1), qeye(2), qeye(2), qeye(2))  , 5.15)
        elif action == 'X2': return (tensor(qeye(2), qeye(2), sigmax(), qeye(2), qeye(2)), 2.4)
        elif action == 'Y2': return (tensor(qeye(2), qeye(2), sigmay(), qeye(2), qeye(2)), 2.4)
        elif action == 'Z2': return (tensor(qeye(2), qeye(2), sigmaz(), qeye(2), qeye(2)), 2.4)
        elif action == 'H2': return (tensor(qeye(2), qeye(2), snot(N=1), qeye(2), qeye(2))  , 2.4)
        elif action == 'X3': return (tensor(qeye(2), qeye(2), qeye(2), sigmax(), qeye(2)), 2.74)
        elif action == 'Y3': return (tensor(qeye(2), qeye(2), qeye(2), sigmay(), qeye(2)), 2.74)
        elif action == 'Z3': return (tensor(qeye(2), qeye(2), qeye(2), sigmaz(), qeye(2)), 2.74)
        elif action == 'H3': return (tensor(qeye(2), qeye(2), qeye(2), snot(N=1), qeye(2))  , 2.74)
        elif action == 'X4': return (tensor(qeye(2), qeye(2), qeye(2), qeye(2), sigmax()), 2.91)
        elif action == 'Y4': return (tensor(qeye(2), qeye(2), qeye(2), qeye(2), sigmay()), 2.91)
        elif action == 'Z4': return (tensor(qeye(2), qeye(2), qeye(2), qeye(2), sigmaz()), 2.91)
        elif action == 'H4': return (tensor(qeye(2), qeye(2), qeye(2), qeye(2), snot(N=1))  , 2.91)
        elif action == 'CNOT10': return (cnot(N=5, control=1, target=0), 24.8)
        elif action == 'CNOT20': return (cnot(N=5, control=2, target=0), 23.8)
        elif action == 'CNOT21': return (cnot(N=5, control=2, target=1), 49.7)
        elif action == 'CNOT32': return (cnot(N=5, control=3, target=2), 52.2)
        elif action == 'CNOT34': return (cnot(N=5, control=3, target=4), 38.9)
        elif action == 'CNOT42': return (cnot(N=5, control=4, target=2), 52.8)

    # Update circuit depth
    def calculate_circuit_depth(self, a):
        if a == 'X0' or a == 'Y0' or a == 'Z0' or a == 'H0':
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)
        elif a == 'X1' or a == 'Y1' or a == 'Z1' or a == 'H1':
            self.circuit_depths[1] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[1].append(a)
                return max(self.circuit_depths)
        elif a == 'X2' or a == 'Y2' or a == 'Z2' or a == 'H2':
            self.circuit_depths[2] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[2].append(a)
                return max(self.circuit_depths)
        elif a == 'X3' or a == 'Y3' or a == 'Z3' or a == 'H3':
            self.circuit_depths[3] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[3].append(a)
                return max(self.circuit_depths)
        elif a == 'X4' or a == 'Y4' or a == 'Z4' or a == 'H4':
            self.circuit_depths[4] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[4].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT10':
            self.circuit_depths[1] = max(self.circuit_depths[0], self.circuit_depths[1])
            self.circuit_depths[0] = max(self.circuit_depths[0], self.circuit_depths[1])
            self.circuit_depths[1] += 1
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[1].append(a)
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT20':
            self.circuit_depths[2] = max(self.circuit_depths[0], self.circuit_depths[2])
            self.circuit_depths[0] = max(self.circuit_depths[0], self.circuit_depths[2])
            self.circuit_depths[2] += 1
            self.circuit_depths[0] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[2].append(a)
                self.circuit_gates[0].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT21':
            self.circuit_depths[2] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[1] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[2] += 1
            self.circuit_depths[1] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[2].append(a)
                self.circuit_gates[1].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT32':
            self.circuit_depths[3] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[2] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[3] += 1
            self.circuit_depths[2] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[3].append(a)
                self.circuit_gates[2].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT34':
            self.circuit_depths[3] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[4] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[3] += 1
            self.circuit_depths[4] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[3].append(a)
                self.circuit_gates[4].append(a)
                return max(self.circuit_depths)
        elif a == 'CNOT42':
            self.circuit_depths[4] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[2] = max(self.circuit_depths[1], self.circuit_depths[2])
            self.circuit_depths[4] += 1
            self.circuit_depths[2] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[4].append(a)
                self.circuit_gates[2].append(a)
                return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return 1000
        else:
            return 0

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self,action):
        s_prev = self.s
        a, e = self.action2matrix(action)
        self.sum_error += e
        self.s = a*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action)
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if max(self.circuit_depths) > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            output = open('output.out', 'a')
            print("Gates:\n", file = output)
            print("qubit 0: ", self.circuit_gates[0], file = output)
            print("qubit 1: ", self.circuit_gates[1], file = output)
            print("qubit 2: ", self.circuit_gates[2], file = output)
            print("qubit 3: ", self.circuit_gates[3], file = output)
            print("qubit 4: ", self.circuit_gates[4], file = output)
            print("min circuit depth: ", self.min_circuit_depth, file = output)
            print("Right circuit", reward, file = output)
            print("\n", file = output)
            output.close()
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |00000>
    def init_comp_basis(self):
        comp_basis = tensor(basis(2,0), basis(2,0), basis(2,0), basis(2,0), basis(2,0))
        return comp_basis

