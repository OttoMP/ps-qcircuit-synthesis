import numpy as np
from qutip.tensor import tensor
from qutip.states import basis, ket2dm
from qutip.metrics import tracedist
from qutip.operators import sigmax, sigmay, sigmaz, qeye
from qutip.qip.operations import swap, iswap, rx, ry, rz, snot, cnot, phasegate
from copy import deepcopy

### QuantumCircuitEnv environment
# Error Values from 27-01-2021

class Melbourne:

    def __init__(self, num_qubits, max_circuit_depth, goal_state, reward, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = {'X':sigmax(),
                             'Y':sigmay(),
                             'Z':sigmaz(),
                             'T':phasegate(np.pi/4),
                             'H':snot(N=1),
                             'CNOT':qeye(2)}

        self.error_single = {0:5.032,
                             1:9.981,
                             2:14.84,
                             3:4.412,
                             4:10.44,
                             5:27.81,
                             6:13.13,
                             7:22.35,
                             8:7.427,
                             9:14.7,
                             10:12.09,
                             11:7.119,
                             12:11.86,
                             13:24.81,
                             14:8.069}


        self.error_mult = {(0,1):180.1,
                           (0,14):320.6,
                           (1,2):180.4,
                           (1,13):611.1,
                           (2,3):222.5,
                           (2,12):490.9,
                           (3,4):173,
                           (3,11):344.7,
                           (4,5):256.6,
                           (4,10):294.9,
                           (5,6):476,
                           (5,9):411.2,
                           (6,8):293.6,
                           (7,8):312.1,
                           (8,9):311.4,
                           (9,10):340.5,
                           (10,11):300,
                           (11,12):290.8,
                           (12,13):372,
                           (13,14):851.6}

        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = num_qubits               # Number of qubits in circuit
        self.reward = reward                       # Reward given to a succesful circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Set the maximum number of qubits to the limits of the architecture
        if self.num_qubits > 15:
            self.num_qubits = 15
        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action, controlled, pos_con, pos_tar):
        # Return gate matrix from action space
        gate = self.action_space[action]

        # If gate is not controlled, create the tensor product to apply in the right qubit
        if not controlled:
            for q in range(self.num_qubits):
                if q == pos_tar:
                    pass
                if q > pos_tar:
                    gate = tensor(gate, qeye(2))
                if q < pos_tar:
                    gate = tensor(qeye(2), gate)
        else:
            gate = cnot(N=self.num_qubits, control=pos_con, target=pos_tar)

        return gate

    # Update circuit depth
    def calculate_circuit_depth(self, a, controlled, pos_con, pos_tar):
        if controlled:
            self.circuit_depths[pos_con] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_tar] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_con] += 1
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_con].append(a)
                self.circuit_gates[pos_tar].append(a)
        else:
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_tar].append(a)

        return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return self.reward
        else:
            return 0

    def print_circuit(self, reward):
        # Printing results in output.out
        output = open('output.out', 'a')
        print("Gates:", file = output)
        for qubit in range(self.num_qubits):
            print("qubit " + str(qubit) + ": ", self.circuit_gates[qubit], file = output)
        print("min circuit depth: ", self.min_circuit_depth, file = output)
        print("Final State", self.s, file = output)
        print("Error", self.sum_error, file = output)
        print("Reward", reward, file = output)
        print("\n", file = output)
        output.close()

        return

    def calc_error(self, pos_con, pos_tar):
        if pos_con == pos_tar:
            error = self.error_single[pos_tar]
        else:
            error = self.error_mult[(min(pos_con, pos_tar), max(pos_con, pos_tar))]

        self.sum_error += error
        return

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self, action_tuple):
        #s_prev = self.s
        gate_matrix = self.action2matrix(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.calc_error(action_tuple[2], action_tuple[3])
        self.s = gate_matrix*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if depth > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            self.print_circuit(reward)
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |0...0>
    def init_comp_basis(self):
        comp_basis = basis(2,0)
        for q in range(self.num_qubits-1):
            comp_basis = tensor(comp_basis, basis(2,0))
        return comp_basis

class Athens:

    def __init__(self, num_qubits, max_circuit_depth, goal_state, reward, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = {'X':sigmax(),
                             'Y':sigmay(),
                             'Z':sigmaz(),
                             'T':phasegate(np.pi/4),
                             'H':snot(N=1),
                             'CNOT':qeye(2)}

        self.error_single = {0:6.5,
                             1:11.3,
                             2:16,
                             3:41,
                             4:18.3,
        }

        self.error_mult = {(0,1):13.29,
                           (1,2):7.626,
                           (2,3):7.125,
                           (3,4):8.238,
        }

        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = num_qubits               # Number of qubits in circuit
        self.reward = reward                       # Reward given to a succesful circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Set the maximum number of qubits to the limits of the architecture
        if self.num_qubits > 5:
            self.num_qubits = 5
        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action, controlled, pos_con, pos_tar):
        # Return gate matrix from action space
        gate = self.action_space[action]

        # If gate is not controlled, create the tensor product to apply in the right qubit
        if not controlled:
            for q in range(self.num_qubits):
                if q == pos_tar:
                    pass
                if q > pos_tar:
                    gate = tensor(gate, qeye(2))
                if q < pos_tar:
                    gate = tensor(qeye(2), gate)
        else:
            gate = cnot(N=self.num_qubits, control=pos_con, target=pos_tar)

        return gate

    # Update circuit depth
    def calculate_circuit_depth(self, a, controlled, pos_con, pos_tar):
        if controlled:
            self.circuit_depths[pos_con] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_tar] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_con] += 1
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_con].append(a)
                self.circuit_gates[pos_tar].append(a)
        else:
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_tar].append(a)

        return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return self.reward
        else:
            return 0

    def print_circuit(self, reward):
        # Printing results in output.out
        output = open('output.out', 'a')
        print("Gates:", file = output)
        for qubit in range(self.num_qubits):
            print("qubit " + str(qubit) + ": ", self.circuit_gates[qubit], file = output)
        print("min circuit depth: ", self.min_circuit_depth, file = output)
        print("Final State", self.s, file = output)
        print("Error", self.sum_error, file = output)
        print("Reward", reward, file = output)
        print("\n", file = output)
        output.close()

        return

    def calc_error(self, pos_con, pos_tar):
        if pos_con == pos_tar:
            error = self.error_single[pos_tar]
        else:
            error = self.error_mult[(min(pos_con, pos_tar), max(pos_con, pos_tar))]

        self.sum_error += error
        return

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self, action_tuple):
        #s_prev = self.s
        gate_matrix = self.action2matrix(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.calc_error(action_tuple[2], action_tuple[3])
        self.s = gate_matrix*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if depth > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            self.print_circuit(reward)
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |0...0>
    def init_comp_basis(self):
        comp_basis = basis(2,0)
        for q in range(self.num_qubits-1):
            comp_basis = tensor(comp_basis, basis(2,0))
        return comp_basis

class Santiago:

    def __init__(self, num_qubits, max_circuit_depth, goal_state, reward, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = {'X':sigmax(),
                             'Y':sigmay(),
                             'Z':sigmaz(),
                             'T':phasegate(np.pi/4),
                             'H':snot(N=1),
                             'CNOT':qeye(2)}

        self.error_single = {0:17.8,
                             1:16.7,
                             2:10,
                             3:40.5,
                             4:12.6,
        }

        self.error_mult = {(0,1):13.75,
                           (1,2):12.57,
                           (2,3):7.208,
                           (3,4):7.533,
        }

        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = num_qubits               # Number of qubits in circuit
        self.reward = reward                       # Reward given to a succesful circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Set the maximum number of qubits to the limits of the architecture
        if self.num_qubits > 5:
            self.num_qubits = 5
        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action, controlled, pos_con, pos_tar):
        # Return gate matrix from action space
        gate = self.action_space[action]

        # If gate is not controlled, create the tensor product to apply in the right qubit
        if not controlled:
            for q in range(self.num_qubits):
                if q == pos_tar:
                    pass
                if q > pos_tar:
                    gate = tensor(gate, qeye(2))
                if q < pos_tar:
                    gate = tensor(qeye(2), gate)
        else:
            gate = cnot(N=self.num_qubits, control=pos_con, target=pos_tar)

        return gate

    # Update circuit depth
    def calculate_circuit_depth(self, a, controlled, pos_con, pos_tar):
        if controlled:
            self.circuit_depths[pos_con] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_tar] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_con] += 1
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_con].append(a)
                self.circuit_gates[pos_tar].append(a)
        else:
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_tar].append(a)

        return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return self.reward
        else:
            return 0

    def print_circuit(self, reward):
        # Printing results in output.out
        output = open('output.out', 'a')
        print("Gates:", file = output)
        for qubit in range(self.num_qubits):
            print("qubit " + str(qubit) + ": ", self.circuit_gates[qubit], file = output)
        print("min circuit depth: ", self.min_circuit_depth, file = output)
        print("Final State", self.s, file = output)
        print("Error", self.sum_error, file = output)
        print("Reward", reward, file = output)
        print("\n", file = output)
        output.close()

        return

    def calc_error(self, pos_con, pos_tar):
        if pos_con == pos_tar:
            error = self.error_single[pos_tar]
        else:
            error = self.error_mult[(min(pos_con, pos_tar), max(pos_con, pos_tar))]

        self.sum_error += error
        return

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self, action_tuple):
        #s_prev = self.s
        gate_matrix = self.action2matrix(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.calc_error(action_tuple[2], action_tuple[3])
        self.s = gate_matrix*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if depth > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            self.print_circuit(reward)
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |0...0>
    def init_comp_basis(self):
        comp_basis = basis(2,0)
        for q in range(self.num_qubits-1):
            comp_basis = tensor(comp_basis, basis(2,0))
        return comp_basis

class Valencia:

    def __init__(self, num_qubits, max_circuit_depth, goal_state, reward, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = {'X':sigmax(),
                             'Y':sigmay(),
                             'Z':sigmaz(),
                             'T':phasegate(np.pi/4),
                             'H':snot(N=1),
                             'CNOT':qeye(2)}

        self.error_single = {0:34.8,
                             1:23.4,
                             2:47.9,
                             3:30.3,
                             4:54.2,
        }

        self.error_mult = {(0,1):7.325,
                           (1,2):10.63,
                           (1,3):10.35,
                           (3,4):12.96,
        }

        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = num_qubits               # Number of qubits in circuit
        self.reward = reward                       # Reward given to a succesful circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Set the maximum number of qubits to the limits of the architecture
        if self.num_qubits > 5:
            self.num_qubits = 5
        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action, controlled, pos_con, pos_tar):
        # Return gate matrix from action space
        gate = self.action_space[action]

        # If gate is not controlled, create the tensor product to apply in the right qubit
        if not controlled:
            for q in range(self.num_qubits):
                if q == pos_tar:
                    pass
                if q > pos_tar:
                    gate = tensor(gate, qeye(2))
                if q < pos_tar:
                    gate = tensor(qeye(2), gate)
        else:
            gate = cnot(N=self.num_qubits, control=pos_con, target=pos_tar)

        return gate

    # Update circuit depth
    def calculate_circuit_depth(self, a, controlled, pos_con, pos_tar):
        if controlled:
            self.circuit_depths[pos_con] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_tar] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_con] += 1
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_con].append(a)
                self.circuit_gates[pos_tar].append(a)
        else:
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_tar].append(a)

        return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return self.reward
        else:
            return 0

    def print_circuit(self, reward):
        # Printing results in output.out
        output = open('output.out', 'a')
        print("Gates:", file = output)
        for qubit in range(self.num_qubits):
            print("qubit " + str(qubit) + ": ", self.circuit_gates[qubit], file = output)
        print("min circuit depth: ", self.min_circuit_depth, file = output)
        print("Final State", self.s, file = output)
        print("Error", self.sum_error, file = output)
        print("Reward", reward, file = output)
        print("\n", file = output)
        output.close()

        return

    def calc_error(self, pos_con, pos_tar):
        if pos_con == pos_tar:
            error = self.error_single[pos_tar]
        else:
            error = self.error_mult[(min(pos_con, pos_tar), max(pos_con, pos_tar))]

        self.sum_error += error
        return

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self, action_tuple):
        #s_prev = self.s
        gate_matrix = self.action2matrix(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.calc_error(action_tuple[2], action_tuple[3])
        self.s = gate_matrix*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if depth > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            self.print_circuit(reward)
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |0...0>
    def init_comp_basis(self):
        comp_basis = basis(2,0)
        for q in range(self.num_qubits-1):
            comp_basis = tensor(comp_basis, basis(2,0))
        return comp_basis

class Vigo:

    def __init__(self, num_qubits, max_circuit_depth, goal_state, reward, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = {'X':sigmax(),
                             'Y':sigmay(),
                             'Z':sigmaz(),
                             'T':phasegate(np.pi/4),
                             'H':snot(N=1),
                             'CNOT':qeye(2)}

        self.error_single = {0:75.1,
                             1:22.5,
                             2:14.6,
                             3:21.5,
                             4:33.3,
        }

        self.error_mult = {(0,1):12.01,
                           (1,2):6.59,
                           (1,3):9.297,
                           (3,4):7.13,
        }

        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = num_qubits               # Number of qubits in circuit
        self.reward = reward                       # Reward given to a succesful circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Set the maximum number of qubits to the limits of the architecture
        if self.num_qubits > 5:
            self.num_qubits = 5
        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action, controlled, pos_con, pos_tar):
        # Return gate matrix from action space
        gate = self.action_space[action]

        # If gate is not controlled, create the tensor product to apply in the right qubit
        if not controlled:
            for q in range(self.num_qubits):
                if q == pos_tar:
                    pass
                if q > pos_tar:
                    gate = tensor(gate, qeye(2))
                if q < pos_tar:
                    gate = tensor(qeye(2), gate)
        else:
            gate = cnot(N=self.num_qubits, control=pos_con, target=pos_tar)

        return gate

    # Update circuit depth
    def calculate_circuit_depth(self, a, controlled, pos_con, pos_tar):
        if controlled:
            self.circuit_depths[pos_con] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_tar] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_con] += 1
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_con].append(a)
                self.circuit_gates[pos_tar].append(a)
        else:
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_tar].append(a)

        return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return self.reward
        else:
            return 0

    def print_circuit(self, reward):
        # Printing results in output.out
        output = open('output.out', 'a')
        print("Gates:", file = output)
        for qubit in range(self.num_qubits):
            print("qubit " + str(qubit) + ": ", self.circuit_gates[qubit], file = output)
        print("min circuit depth: ", self.min_circuit_depth, file = output)
        print("Final State", self.s, file = output)
        print("Error", self.sum_error, file = output)
        print("Reward", reward, file = output)
        print("\n", file = output)
        output.close()

        return

    def calc_error(self, pos_con, pos_tar):
        if pos_con == pos_tar:
            error = self.error_single[pos_tar]
        else:
            error = self.error_mult[(min(pos_con, pos_tar), max(pos_con, pos_tar))]

        self.sum_error += error
        return

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self, action_tuple):
        #s_prev = self.s
        gate_matrix = self.action2matrix(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.calc_error(action_tuple[2], action_tuple[3])
        self.s = gate_matrix*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if depth > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            self.print_circuit(reward)
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |0...0>
    def init_comp_basis(self):
        comp_basis = basis(2,0)
        for q in range(self.num_qubits-1):
            comp_basis = tensor(comp_basis, basis(2,0))
        return comp_basis

class Yorktown:

    def __init__(self, num_qubits, max_circuit_depth, goal_state, reward, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = {'X':sigmax(),
                             'Y':sigmay(),
                             'Z':sigmaz(),
                             'T':phasegate(np.pi/4),
                             'H':snot(N=1),
                             'CNOT':qeye(2)}

        self.error_single = {0:25.9,
                             1:26.1,
                             2:88.8,
                             3:57.9,
                             4:33.9,
        }

        self.error_mult = {(0,1):19.95,
                           (0,2):15.63,
                           (1,2):22.96,
                           (2,3):18.56,
                           (2,4):17.52,
                           (3,4):21.11,
        }

        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = num_qubits               # Number of qubits in circuit
        self.reward = reward                       # Reward given to a succesful circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Set the maximum number of qubits to the limits of the architecture
        if self.num_qubits > 5:
            self.num_qubits = 5
        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action, controlled, pos_con, pos_tar):
        # Return gate matrix from action space
        gate = self.action_space[action]

        # If gate is not controlled, create the tensor product to apply in the right qubit
        if not controlled:
            for q in range(self.num_qubits):
                if q == pos_tar:
                    pass
                if q > pos_tar:
                    gate = tensor(gate, qeye(2))
                if q < pos_tar:
                    gate = tensor(qeye(2), gate)
        else:
            gate = cnot(N=self.num_qubits, control=pos_con, target=pos_tar)

        return gate

    # Update circuit depth
    def calculate_circuit_depth(self, a, controlled, pos_con, pos_tar):
        if controlled:
            self.circuit_depths[pos_con] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_tar] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_con] += 1
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_con].append(a)
                self.circuit_gates[pos_tar].append(a)
        else:
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_tar].append(a)

        return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return self.reward
        else:
            return 0

    def print_circuit(self, reward):
        # Printing results in output.out
        output = open('output.out', 'a')
        print("Gates:", file = output)
        for qubit in range(self.num_qubits):
            print("qubit " + str(qubit) + ": ", self.circuit_gates[qubit], file = output)
        print("min circuit depth: ", self.min_circuit_depth, file = output)
        print("Final State", self.s, file = output)
        print("Error", self.sum_error, file = output)
        print("Reward", reward, file = output)
        print("\n", file = output)
        output.close()

        return

    def calc_error(self, pos_con, pos_tar):
        if pos_con == pos_tar:
            error = self.error_single[pos_tar]
        else:
            error = self.error_mult[(min(pos_con, pos_tar), max(pos_con, pos_tar))]

        self.sum_error += error
        return

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self, action_tuple):
        #s_prev = self.s
        gate_matrix = self.action2matrix(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.calc_error(action_tuple[2], action_tuple[3])
        self.s = gate_matrix*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if depth > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            self.print_circuit(reward)
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |0...0>
    def init_comp_basis(self):
        comp_basis = basis(2,0)
        for q in range(self.num_qubits-1):
            comp_basis = tensor(comp_basis, basis(2,0))
        return comp_basis
