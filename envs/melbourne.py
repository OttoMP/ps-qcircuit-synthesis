import numpy as np
from qutip import tensor, basis, sigmax, sigmay, sigmaz, qeye, rx, ry, rz, snot, cnot, ket2dm, tracedist
from copy import deepcopy

### QuantumCircuitEnv environment

class IBMQMelbourne:

    def __init__(self, num_qubits, max_circuit_depth, goal_state, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        #TODO
        self.action_space = {}
        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = num_qubits               # Number of qubits in circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Set the maximum number of qubits to the limits of the architecture
        if self.num_qubits > 15:
            self.num_qubits = 15
        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action, pos_gate):
        # Return gate description from action space
        gate, error = self.action_space[action]
        #elif action == 'CNOT10': return (cnot(N=self.num_qubits, control=pos_con, target=pos_tar), 23.8)

        # Matrices representation of the possible gates
        for q in range(self.num_qubits):
            if q == pos_gate:
                pass
            if q < pos_gate:
                gate = tensor(qeye(2), gate)
            if q > pos_gate:
                gate = tensor(gate, qeye(2))

        return gate, error

    # Update circuit depth
    def calculate_circuit_depth(self, a, pos_gate):
        #TODO in case gate is controlled
        '''
        if a == 'CNOT10':
            self.circuit_depths[pos_con] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_tar] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_con] += 1
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) > self.max_circuit_depth:
                return self.max_circuit_depth
            else:
                self.circuit_gates[pos_con].append(a)
                self.circuit_gates[pos_tar].append(a)
                return max(self.circuit_depths)
        else:
        '''
        self.circuit_depths[pos_gate] += 1
        if max(self.circuit_depths) > self.max_circuit_depth:
            return self.max_circuit_depth
        else:
            self.circuit_gates[pos_gate].append(a)
            return max(self.circuit_depths)

            # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return 100
        else:
            return 0

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self, action, position):
        s_prev = self.s
        a, e = self.action2matrix(action, position)
        self.sum_error += e
        self.s = a*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action, position)
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if max(self.circuit_depths) > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            output = open('output.out', 'a')
            print("Gates:", file = output)
            print("qubit 0: ", self.circuit_gates[0], file = output)
            print("qubit 1: ", self.circuit_gates[1], file = output)
            print("min circuit depth: ", self.min_circuit_depth, file = output)
            print("Reward", reward, file = output)
            print("\n", file = output)
            output.close()
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |0...0>
    def init_comp_basis(self):
        comp_basis = basis(2,0)
        for q in range(num_qubits-1):
            comp_basis = tensor(comp_basis, basis(2,0))
        return comp_basis
