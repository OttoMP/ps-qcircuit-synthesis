import numpy as np
from qutip import tensor, basis, sigmax, sigmay, sigmaz, qeye, rx, ry, rz, snot, cnot, ket2dm, tracedist
from copy import deepcopy

### QuantumCircuitEnv environment

class IBMQmelbourne:

    def __init__(self, num_qubits, max_circuit_depth, goal_state, tolerance):
        # State and action space
        # self.S = Column vector generated from tensor product of qubits
        # self.action_space = list of the name of the possible gates to use in
        #       the circuit. Every action follows the naming rule "Gn" where G
        #       is the name of the gate and n is the number of the qubit
        #       affected by the gate. CNOT gates follow the rule "CNOTct" where
        #       c is the number of the control qubit and t is the number of the
        #       target qubit.

        # Reward structure
        # self.calc_trace_distance()

        # Transitions
        # self.operate()

        self.action_space = {'X':sigmax(),
                             'Y':sigmay(),
                             'Z':sigmaz(),
                             'H':snot(N=1),
                             'CNOT':qeye(2)}

        self.error_single = {0:5.032,
                             1:9.981,
                             2:14.84,
                             3:4.412,
                             4:10.44,
                             5:27.81,
                             6:13.13,
                             7:22.35,
                             8:7.427,
                             9:14.7,
                             10:12.09,
                             11:7.119,
                             12:11.86,
                             13:24.81,
                             14:8.069}


        self.error_mult = {(0,1):180.1,
                           (0,14):320.6,
                           (1,2):180.4,
                           (1,13):611.1,
                           (2,3):222.5,
                           (2,12):490.9,
                           (3,4):173,
                           (3,11):344.7,
                           (4,5):256.6,
                           (4,10):294.9,
                           (5,6):476,
                           (5,9):411.2,
                           (6,8):293.6,
                           (7,8):312.1,
                           (8,9):311.4,
                           (9,10):340.5,
                           (10,11):300,
                           (11,12):290.8,
                           (12,13):372,
                           (13,14):851.6}

        self.max_circuit_depth = max_circuit_depth # Maximum depth accepted by
                                                   # the circuit
        self.min_circuit_depth = max_circuit_depth # Minimum depth found while
                                                   # generating circuits
        self.goal_state = goal_state               # Quantum state to be
                                                   # generated by the circuit
        self.num_qubits = num_qubits               # Number of qubits in circuit
        self.tolerance = tolerance                 # Tolerance of trace distance

        # Set the maximum number of qubits to the limits of the architecture
        if self.num_qubits > 15:
            self.num_qubits = 15
        # Number of gates applied to each qubit
        self.circuit_depths = np.zeros(self.num_qubits)
        # Gates applied to each qubit
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        # Sum of the gate errors in the circuit
        self.sum_error = 0

    # Reset the internal state of the circuit and return all qubits in the
    # computational basis
    def reset(self):
        self.s = self.init_comp_basis()
        self.circuit_depths = np.zeros(self.num_qubits)
        self.circuit_gates = [[] for q in range(self.num_qubits)]
        self.sum_error = 0
        self.is_reset = True

        return self.s

    # Return corresponding matrix of given gate
    def action2matrix(self, action, controlled, pos_con, pos_tar):
        # Return gate matrix from action space
        gate = self.action_space[action]

        # If gate is not controlled, create the tensor product to apply in the right qubit
        if not controlled:
            for q in range(self.num_qubits):
                if q == pos_tar:
                    pass
                if q < pos_tar:
                    gate = tensor(gate, qeye(2))
                if q > pos_tar:
                    gate = tensor(qeye(2), gate)
        else:
            gate = cnot(N=self.num_qubits, control=pos_con, target=pos_tar)

        return gate

    # Update circuit depth
    def calculate_circuit_depth(self, a, controlled, pos_con, pos_tar):
        if controlled:
            self.circuit_depths[pos_con] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_tar] = max(self.circuit_depths[pos_tar], self.circuit_depths[pos_con])
            self.circuit_depths[pos_con] += 1
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_con].append(a)
                self.circuit_gates[pos_tar].append(a)
        else:
            self.circuit_depths[pos_tar] += 1
            if max(self.circuit_depths) <= self.max_circuit_depth:
                self.circuit_gates[pos_tar].append(a)

        return max(self.circuit_depths)

    # Calculate trace distance between current state and goal state
    def calc_trace_distance(self, s):
        density_s = ket2dm(s)
        density_goal = ket2dm(self.goal_state)
        trace = tracedist(density_s, density_goal)

        if trace < self.tolerance:
            return 10000
        else:
            return 0

    def print_circuit(self, reward):
        # Printing results in output.out
        output = open('output.out', 'a')
        print("Gates:", file = output)
        print("qubit 0: ", self.circuit_gates[0], file = output)
        print("qubit 1: ", self.circuit_gates[1], file = output)
        print("min circuit depth: ", self.min_circuit_depth, file = output)
        #print("Final State", self.s, file = output)
        print("Error", self.sum_error, file = output)
        print("Reward", reward, file = output)
        print("\n", file = output)
        output.close()

        return

    def calc_error(self, pos_con, pos_tar):
        if pos_con == pos_tar:
            error = self.error_single[pos_tar]
        else:
            error = self.error_mult[(min(pos_con, pos_tar), max(pos_con, pos_tar))]

        self.sum_error += error
        return

    # Given an action, update internal state and return reward. If a final
    # state is reached, reset environment
    def step(self, action_tuple):
        #s_prev = self.s
        gate_matrix = self.action2matrix(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.calc_error(action_tuple[2], action_tuple[3])
        self.s = gate_matrix*self.s # Multiply gate matrix and qubit vector
        reward = self.calc_trace_distance(self.s)
        depth = self.calculate_circuit_depth(action_tuple[0], action_tuple[1], action_tuple[2], action_tuple[3])
        self.is_reset = False
        circuit_gates_return = deepcopy(self.circuit_gates)

        # If current circuit was rewarded or maximum circuit depth reached,
        # print result and reset environment
        if depth > self.max_circuit_depth:
            self.reset()
            reward = 0

        if reward > 0:
            reward = (reward-self.sum_error) * (self.min_circuit_depth/(depth))
            if self.min_circuit_depth > depth:
                self.min_circuit_depth = depth
            self.print_circuit(reward)
            self.reset()

        return (self.s, reward, self.is_reset, circuit_gates_return)

    # Return the computational basis |0...0>
    def init_comp_basis(self):
        comp_basis = basis(2,0)
        for q in range(self.num_qubits-1):
            comp_basis = tensor(comp_basis, basis(2,0))
        return comp_basis
